#!/bin/bash

# AI Code Review Script
# This script simulates an AI reviewing the code generated by another AI

# Default values
WORKSPACE="."
BRANCH="ai-generated-code"
ITERATION=0
FEATURE="feature"
DEBUG=false

# Parse command line arguments
for arg in "$@"; do
    case $arg in
        --workspace=*)
        WORKSPACE="${arg#*=}"
        shift
        ;;
        --branch=*)
        BRANCH="${arg#*=}"
        shift
        ;;
        --iteration=*)
        ITERATION="${arg#*=}"
        shift
        ;;
        --feature=*)
        FEATURE="${arg#*=}"
        shift
        ;;
        --debug)
        DEBUG=true
        shift
        ;;
        *)
        # Unknown option
        ;;
    esac
done

echo "Running AI Code Review for $FEATURE (Iteration $ITERATION)"

# Create a directory for storing AI review results
REVIEW_DIR="$WORKSPACE/.ai-pipeline-iterations/iteration-$ITERATION/step-ai_review"
mkdir -p "$REVIEW_DIR"

# In a real implementation, this would:
# 1. Extract the changes made by the AI
# 2. Send those changes to a secondary AI for review
# 3. Get feedback and suggestions
# 4. Potentially make automated fixes for simple issues

# For this dummy implementation, we'll:
# 1. List changed files
# 2. Simulate an AI review with increasingly positive feedback

# List changed files (if the branch exists)
git show-ref --verify --quiet refs/heads/$BRANCH
if [ $? -eq 0 ]; then
    # Branch exists, list changed files
    echo "Checking files changed in branch $BRANCH"
    git diff --name-only main..$BRANCH > "$REVIEW_DIR/changed_files.txt"
    CHANGED_COUNT=$(wc -l < "$REVIEW_DIR/changed_files.txt")
    echo "Found $CHANGED_COUNT changed files"
    
    # If there are no changed files, exit successfully
    if [ $CHANGED_COUNT -eq 0 ]; then
        echo "No files changed, AI review skipped"
        exit 0
    fi
else
    # Branch doesn't exist yet
    echo "Branch $BRANCH does not exist yet. Skipping file diff."
    echo "No files changed yet" > "$REVIEW_DIR/changed_files.txt"
    echo "No files changed, AI review skipped"
    exit 0
fi

# Simulate the AI review process
echo "Simulating AI code review..."

# Get diff content to review
git diff main..$BRANCH > "$REVIEW_DIR/full_diff.patch"

# Calculate metrics based on iteration
# As iterations progress, the review should become more positive
if [ $ITERATION -eq 0 ]; then
    # First iteration, more issues
    OVERALL_SCORE=$((40 + RANDOM % 20))  # 40-59
    MAJOR_ISSUES=$((RANDOM % 5 + 3))     # 3-7
    MINOR_ISSUES=$((RANDOM % 8 + 5))     # 5-12
    SECURITY_ISSUES=$((RANDOM % 3 + 1))  # 1-3
    PERFORMANCE_ISSUES=$((RANDOM % 4 + 2)) # 2-5
    STYLE_ISSUES=$((RANDOM % 10 + 5))    # 5-14
elif [ $ITERATION -lt 3 ]; then
    # Middle iterations, fewer issues
    OVERALL_SCORE=$((60 + RANDOM % 20))  # 60-79
    MAJOR_ISSUES=$((RANDOM % 3))         # 0-2
    MINOR_ISSUES=$((RANDOM % 5 + 2))     # 2-6
    SECURITY_ISSUES=$((RANDOM % 2))      # 0-1
    PERFORMANCE_ISSUES=$((RANDOM % 3))   # 0-2
    STYLE_ISSUES=$((RANDOM % 5 + 2))     # 2-6
else
    # Later iterations, minimal issues
    OVERALL_SCORE=$((80 + RANDOM % 20))  # 80-99
    MAJOR_ISSUES=0                       # 0
    MINOR_ISSUES=$((RANDOM % 3))         # 0-2
    SECURITY_ISSUES=0                    # 0
    PERFORMANCE_ISSUES=$((RANDOM % 2))   # 0-1
    STYLE_ISSUES=$((RANDOM % 3))         # 0-2
fi

TOTAL_ISSUES=$((MAJOR_ISSUES + MINOR_ISSUES + SECURITY_ISSUES + PERFORMANCE_ISSUES + STYLE_ISSUES))

# Generate a review summary
cat > "$REVIEW_DIR/review_summary.json" << EOL
{
  "overall_score": $OVERALL_SCORE,
  "total_issues": $TOTAL_ISSUES,
  "issues_by_severity": {
    "major": $MAJOR_ISSUES,
    "minor": $MINOR_ISSUES,
    "security": $SECURITY_ISSUES,
    "performance": $PERFORMANCE_ISSUES,
    "style": $STYLE_ISSUES
  },
  "files_reviewed": $CHANGED_COUNT,
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
}
EOL

# Generate detailed issues
echo "[]" > "$REVIEW_DIR/detailed_issues.json"

# Function to add an issue to the detailed issues file
add_issue() {
    local severity="$1"
    local category="$2"
    local message="$3"
    local file="$4"
    local line="$5"
    
    local issue="{
        \"severity\": \"$severity\",
        \"category\": \"$category\",
        \"message\": \"$message\",
        \"file\": \"$file\",
        \"line\": $line
    }"
    
    # Add to issues array
    local current_issues=$(cat "$REVIEW_DIR/detailed_issues.json")
    if [ "$current_issues" = "[]" ]; then
        echo "[$issue]" > "$REVIEW_DIR/detailed_issues.json"
    else
        # Remove closing bracket, add comma and new issue, then close bracket
        sed -i.bak 's/\]$/,/' "$REVIEW_DIR/detailed_issues.json"
        echo "$issue]" >> "$REVIEW_DIR/detailed_issues.json"
        rm -f "$REVIEW_DIR/detailed_issues.json.bak"
    fi
}

# Sample issue messages by category
SECURITY_MESSAGES=(
    "Potential SQL injection vulnerability"
    "Insecure direct object reference"
    "Sensitive data exposure"
    "Missing authentication"
    "Cross-site scripting (XSS) vulnerability"
)

PERFORMANCE_MESSAGES=(
    "Inefficient algorithm, consider optimizing"
    "Redundant database query"
    "Memory leak potential"
    "Unnecessary recomputation"
    "Large response payload"
)

MAJOR_MESSAGES=(
    "Incorrect error handling"
    "Race condition possibility"
    "Broken business logic"
    "API contract violation"
    "Data inconsistency risk"
)

MINOR_MESSAGES=(
    "Unclear variable naming"
    "Missing error logging"
    "Duplicate code"
    "Incomplete documentation"
    "Inconsistent return values"
)

STYLE_MESSAGES=(
    "Inconsistent indentation"
    "Non-standard naming convention"
    "Missing or excessive comments"
    "Long function/method"
    "Complex conditional logic"
)

# Generate major issues
for i in $(seq 1 $MAJOR_ISSUES); do
    FILE=$(shuf -n 1 "$REVIEW_DIR/changed_files.txt" 2>/dev/null || echo "unknown_file.txt")
    LINE=$((RANDOM % 100 + 1))
    MESSAGE=${MAJOR_MESSAGES[$((RANDOM % ${#MAJOR_MESSAGES[@]}))]}
    add_issue "major" "logical" "$MESSAGE" "$FILE" "$LINE"
done

# Generate minor issues
for i in $(seq 1 $MINOR_ISSUES); do
    FILE=$(shuf -n 1 "$REVIEW_DIR/changed_files.txt" 2>/dev/null || echo "unknown_file.txt")
    LINE=$((RANDOM % 100 + 1))
    MESSAGE=${MINOR_MESSAGES[$((RANDOM % ${#MINOR_MESSAGES[@]}))]}
    add_issue "minor" "logical" "$MESSAGE" "$FILE" "$LINE"
done

# Generate security issues
for i in $(seq 1 $SECURITY_ISSUES); do
    FILE=$(shuf -n 1 "$REVIEW_DIR/changed_files.txt" 2>/dev/null || echo "unknown_file.txt")
    LINE=$((RANDOM % 100 + 1))
    MESSAGE=${SECURITY_MESSAGES[$((RANDOM % ${#SECURITY_MESSAGES[@]}))]}
    add_issue "critical" "security" "$MESSAGE" "$FILE" "$LINE"
done

# Generate performance issues
for i in $(seq 1 $PERFORMANCE_ISSUES); do
    FILE=$(shuf -n 1 "$REVIEW_DIR/changed_files.txt" 2>/dev/null || echo "unknown_file.txt")
    LINE=$((RANDOM % 100 + 1))
    MESSAGE=${PERFORMANCE_MESSAGES[$((RANDOM % ${#PERFORMANCE_MESSAGES[@]}))]}
    add_issue "minor" "performance" "$MESSAGE" "$FILE" "$LINE"
done

# Generate style issues
for i in $(seq 1 $STYLE_ISSUES); do
    FILE=$(shuf -n 1 "$REVIEW_DIR/changed_files.txt" 2>/dev/null || echo "unknown_file.txt")
    LINE=$((RANDOM % 100 + 1))
    MESSAGE=${STYLE_MESSAGES[$((RANDOM % ${#STYLE_MESSAGES[@]}))]}
    add_issue "trivial" "style" "$MESSAGE" "$FILE" "$LINE"
done

# Generate a textual review (what a human would read)
cat > "$REVIEW_DIR/human_readable_review.md" << EOL
# AI Code Review for $FEATURE (Iteration $ITERATION)

## Overview

Overall Score: **$OVERALL_SCORE/100**

This review is based on changes in branch \`$BRANCH\` compared to \`main\`.

### Summary of Issues

- **Major Issues**: $MAJOR_ISSUES
- **Minor Issues**: $MINOR_ISSUES
- **Security Issues**: $SECURITY_ISSUES
- **Performance Issues**: $PERFORMANCE_ISSUES
- **Style Issues**: $STYLE_ISSUES
- **Total Issues**: $TOTAL_ISSUES

## Detailed Analysis

EOL

# Add some general feedback based on iteration
if [ $ITERATION -eq 0 ]; then
    cat >> "$REVIEW_DIR/human_readable_review.md" << EOL
The initial implementation has several significant issues that need to be addressed. The overall structure shows promise, but there are security concerns, performance bottlenecks, and logical inconsistencies that should be fixed before proceeding.

EOL
elif [ $ITERATION -lt 3 ]; then
    cat >> "$REVIEW_DIR/human_readable_review.md" << EOL
The implementation has improved since the initial version. Most major issues have been addressed, though there are still some areas that could be refined. The code is approaching production quality but needs further polish.

EOL
else
    cat >> "$REVIEW_DIR/human_readable_review.md" << EOL
The implementation is of high quality with only minor issues remaining. The code follows good practices, is secure, and should perform well in production. Well done!

EOL
fi

# Add detailed issues to the human-readable review
cat >> "$REVIEW_DIR/human_readable_review.md" << EOL
## Issues by Category

### Security Issues

EOL

if [ $SECURITY_ISSUES -eq 0 ]; then
    echo "No security issues found." >> "$REVIEW_DIR/human_readable_review.md"
else
    jq -r '.[] | select(.category == "security") | "- **\(.file)** (line \(.line)): \(.message)"' "$REVIEW_DIR/detailed_issues.json" >> "$REVIEW_DIR/human_readable_review.md"
fi

cat >> "$REVIEW_DIR/human_readable_review.md" << EOL

### Major Issues

EOL

if [ $MAJOR_ISSUES -eq 0 ]; then
    echo "No major issues found." >> "$REVIEW_DIR/human_readable_review.md"
else
    jq -r '.[] | select(.severity == "major") | "- **\(.file)** (line \(.line)): \(.message)"' "$REVIEW_DIR/detailed_issues.json" >> "$REVIEW_DIR/human_readable_review.md"
fi

cat >> "$REVIEW_DIR/human_readable_review.md" << EOL

### Performance Issues

EOL

if [ $PERFORMANCE_ISSUES -eq 0 ]; then
    echo "No performance issues found." >> "$REVIEW_DIR/human_readable_review.md"
else
    jq -r '.[] | select(.category == "performance") | "- **\(.file)** (line \(.line)): \(.message)"' "$REVIEW_DIR/detailed_issues.json" >> "$REVIEW_DIR/human_readable_review.md"
fi

cat >> "$REVIEW_DIR/human_readable_review.md" << EOL

### Minor Issues

EOL

if [ $MINOR_ISSUES -eq 0 ]; then
    echo "No minor issues found." >> "$REVIEW_DIR/human_readable_review.md"
else
    jq -r '.[] | select(.severity == "minor") | "- **\(.file)** (line \(.line)): \(.message)"' "$REVIEW_DIR/detailed_issues.json" >> "$REVIEW_DIR/human_readable_review.md"
fi

cat >> "$REVIEW_DIR/human_readable_review.md" << EOL

### Style Issues

EOL

if [ $STYLE_ISSUES -eq 0 ]; then
    echo "No style issues found." >> "$REVIEW_DIR/human_readable_review.md"
else
    jq -r '.[] | select(.severity == "trivial") | "- **\(.file)** (line \(.line)): \(.message)"' "$REVIEW_DIR/detailed_issues.json" >> "$REVIEW_DIR/human_readable_review.md"
fi

# Add recommendations
cat >> "$REVIEW_DIR/human_readable_review.md" << EOL

## Recommendations

EOL

if [ $SECURITY_ISSUES -gt 0 ]; then
    echo "- Address security issues as the highest priority" >> "$REVIEW_DIR/human_readable_review.md"
fi

if [ $MAJOR_ISSUES -gt 0 ]; then
    echo "- Fix major logical issues before proceeding" >> "$REVIEW_DIR/human_readable_review.md"
fi

if [ $PERFORMANCE_ISSUES -gt 0 ]; then
    echo "- Optimize performance bottlenecks" >> "$REVIEW_DIR/human_readable_review.md"
fi

if [ $MINOR_ISSUES -gt 0 ]; then
    echo "- Address minor issues to improve code quality" >> "$REVIEW_DIR/human_readable_review.md"
fi

if [ $STYLE_ISSUES -gt 0 ]; then
    echo "- Clean up style issues for better readability" >> "$REVIEW_DIR/human_readable_review.md"
fi

# Create a summary
cat > "$REVIEW_DIR/summary.txt" << EOL
AI Code Review Summary for $FEATURE (Iteration $ITERATION)
=========================================================
Overall Score: $OVERALL_SCORE/100
Files Reviewed: $CHANGED_COUNT
Total Issues: $TOTAL_ISSUES
  - Major Issues: $MAJOR_ISSUES
  - Minor Issues: $MINOR_ISSUES
  - Security Issues: $SECURITY_ISSUES
  - Performance Issues: $PERFORMANCE_ISSUES
  - Style Issues: $STYLE_ISSUES
EOL

# Check for critical issues that would block the pipeline
if [ $SECURITY_ISSUES -gt 0 ]; then
    echo "WARNING: Security issues detected"
    
    # In a real implementation, security issues might be blocking
    if [ $ITERATION -gt 1 ] && [ $SECURITY_ISSUES -gt 2 ]; then
        echo "ERROR: Multiple security issues in later iterations. Pipeline cannot continue."
        exit 1
    else
        echo "WARNING: Security issues found, but continuing for demonstration purposes."
    fi
fi

if [ $OVERALL_SCORE -lt 50 ]; then
    echo "WARNING: Overall score is below threshold (50)"
    
    # In a real implementation, a low score might be blocking
    if [ $ITERATION -gt 1 ]; then
        echo "ERROR: Low overall score in later iteration. Pipeline cannot continue."
        exit 1
    else
        echo "WARNING: Low score, but continuing for demonstration purposes (first iteration)."
    fi
fi

echo "AI code review completed successfully"
exit 0 