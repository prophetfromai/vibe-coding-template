# Source Code Organization

This directory contains the application source code. This README provides guidance for organizing code that will be generated by AI assistants.

## Directory Structure

- **components/** - UI components and visual elements
- **services/** - Business logic, API integrations, and data operations  
- **utils/** - Helper functions and shared utilities
- **config/** - Application configuration and environment settings

## Principles for AI Code Generation

### 1. Clear Module Boundaries

AI-generated code should have clearly defined module boundaries with explicit inputs and outputs:

```typescript
// Good example - clear boundaries
export function processUserData(userData: UserData): ProcessedUserData {
  // Implementation with clear input/output
}

// Avoid - unclear boundaries and side effects
export function handleUserData(userData: any) {
  // Mixed responsibilities, implicit side effects
  globalState.user = userData;
  makeApiCall(userData);
  updateUI();
}
```

### 2. Defensive Programming

AI code should employ defensive patterns to validate inputs and handle edge cases:

```typescript
// Good example - defensive programming
function transferFunds(amount: number, sourceAccount: Account, targetAccount: Account): Result {
  if (!isValidAmount(amount) || amount <= 0) {
    return { success: false, error: 'Invalid amount' };
  }
  
  if (!sourceAccount || !targetAccount) {
    return { success: false, error: 'Invalid accounts' };
  }
  
  if (sourceAccount.balance < amount) {
    return { success: false, error: 'Insufficient funds' };
  }
  
  // Proceed with transfer logic
}
```

### 3. Feature Isolation

AI-generated features should be isolated with minimal dependencies on existing code:

```
src/
  features/
    user-dashboard/     <- Isolated feature directory
      components/       <- Feature-specific components
      services/         <- Feature-specific services
      types.ts          <- Feature-specific types
      index.ts          <- Public API of the feature
```

### 4. Implementation Patterns

AI should follow these implementation patterns:

- **Single Responsibility Principle** - Each module does one thing well
- **Pure Functions** - Minimize side effects and state mutations
- **Dependency Injection** - Make dependencies explicit
- **Error Handling** - Comprehensive error handling with meaningful messages
- **Type Safety** - Strong typing with no implicit conversions

## AI Code Limitations

AI should NOT implement:

1. Authentication and authorization logic
2. Payment processing or financial transaction logic
3. Security-critical functionality
4. Infrastructure provisioning
5. Sensitive data handling

## Communication Patterns

When requesting implementations for specific modules, provide:

1. Clear purpose and responsibility of the module
2. Expected inputs and outputs with types
3. Error handling expectations
4. Interaction patterns with other modules
5. Performance considerations

## Documentation Requirements

All AI-generated code must include:

1. Function/component-level documentation
2. Type definitions
3. Usage examples
4. Edge case handling explanations 